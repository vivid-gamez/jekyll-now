---
layout: post
title: c++ 생성자
---
C++언어는 Class::를 이용하여 객체를 구현한다.<br>
클래스는 객체를 정의하는 틀, 설계도와 같은 것이고 멤버 함수와 멤버 변수를 선언한다.<br>

기본적으로 C++ 첫포스팅이니 객체 초기화 이전에 서론을 적도록 하겠다.<br>
객체라는 것은 세상의 어떤 요소를 구현한 것이다.<br>

C++에서는 클래스를 설계하고 객체를 생성하고 상속하고 C++에서 제공하는 객체를 사용하게 될 것이다.

자판기를 예시로 들자면 C언어는 절차지향적 프로그래밍이므로 자판기를 구현할때,<br>
돈을 넣는다. 상품을 골라 버튼을 누른다. 이때 돈이 충분하면 > 상품이 나온다, else > 상품이 나오지 않고 X표시를 띄워 거부한다.<br>
와 같은 흐름으로 진행할 것이다.

그러나 C++에서 자판기를 구현한다면, 자판기의 요소들을 구현할 것이다. C++은 객체지향적 프로그래밍이다.<br>
즉 사람과 자판기와 상호작용할 수 있도록 버튼, 상품, 상품출구, 결제 기계 등을 구현 할 것이다.<br>

TV를 예시로 든다면?<br>
TV의 상태: 작동상태(ON/OFF), 채널정보, 음량정보<br> 
TV의 행동: 켜기, 끄기, 채널 이동, 음량 조절<br>
이때 상태(<b>State</b>)가 멤버변수이고 행동(<b>Behavior</b>)이 멤버함수이다.<br>

다음으로 객체에는 세가지 중요한 특성인 캡슐화, 다형성, 상속성이 있다. <br>
<b>캡슐화</b>란 객체의 중요한 정보를 감싸 보호하는 것이다. 이를 통해 보안성을 올리고 그룹화 시킨다는 점또한 장점이다.<br>
캡슐화를 통해 외부에서 내부로의 접근을 막아 함부로 값을 변경하거나 탈취하는 일이 없도록 하는 것이 당연하다.<br>
외부와의 상호작용을 위해 일부를 공개할 수도 있다.

<b>다형성</b>은 한가지 동작을 구현하는 것을 다양하게 한다는 것이다.<br>
예를 들면 animal의 울음소리를 나타내는 growl(animal)함수가 있다.<br>
그럼 이 함수에서 animal이 강아지인지, 고양이인지, 소인지에 따라 growl이라는 함수에서 각각 울음소리를 다르게 구현한다는 것이 다형성이다.<br>
이 개념이 함수의 재정의(<b>Overriding</b>)이라고 한다.
또는 연산자가 더하기의 역할을 하는 것뿐만 아니라, plus라는 의미를 이용하여 두 색을 합치거나, 문자열을 연결하는 것이다.<br>
또는 함수가 같은 기능의 함수일지라도 parameter의 개수 및 타입에 따라 각각 다르게 선언하는 c와 달리 c++은 중복이 가능하다.<br>
이 두 개념이 연산자 중복, 함수 중복 - <b>Overloading</b>의 개념이다.

<b>상속성</b>은 부모와 자식이라는 개념 도입을 통해 부모 클래스의 멤버를 가진 자식 클래스를 통해 상속관계를 둔다는 것이다.<br>
이를 통해 코드의 재사용성을 높여서 소프트웨어의 생산성을 높인다.<br>

본격적으로 기본 생성자에 대해 이야기 해보도록 합니다.

<h2>생성자(Constructor)</h2><br>
1. 생성자란 객체를 생성할 때 필요한 초기작업을 위한 것.<br>
2. 생성자는 함수이며, 리턴타입을 선언하면 컴파일 오류 발생.(※void도 안됨)<br>
3. 생성자는 클래스 이름과 동일하게 작성하여 다른 멤버함수와 구분하도록 한다.<br>
4. 오직 한 번만 실행된다 > 임의로 호출할 수 없다. - 각 객체가 생성될 때 한번만 실행한다.

class **Circle** { // 원을 구현한 클래스<br>
public:<br>
int radius;<br>
Circle**()**</b>; // 매개 변수 없는 생성자 - 함수<br>
Circle**(int r)**; // 매개 변수 있는 생성자 - 함수<br>
double getArea();<br>
};<br>

<h2>기본 생성자(=Default Constructor)</h2><br>
기본적으로 선언하지 않더라도 컴파일러가 생성한 선언자가 바로 기본 생성자이다.<br>
하나라도 생성자가 선언되었다면 기본 생성자가 생성되지 않음을 주의해야한다.<br>

<h2>위임 생성자(=Delegating Constructor)</h2><br>
원을 구현한 클래스 Circle을 보도록 하자.

class Circle { <br>
public:<br>
int radius;<br>
Circle(); // 매개 변수 없는 생성자<br>
Circle(int r); // 매개 변수 있는 생성자<br>
double getArea();<br>
};<br>

여기서 매개변수의 개수가 가장 많은 Circle(int r)을 사용하여 : 타겟 생성자라고 부름<br>
Circle() 기본 생성자를 초기화할 수 있다. : 위임 생성자라고 부름<br>
위임 생성자는  위임생성자 : 타겟 생성자(Param) 형태로 구현한다.<br>

즉, Circle:: Circle() { int radius = 0 }으로 초기화할 것을 Circle:: Circle() : Circle(0) {}으로 표현하면,<br>
Circle(int r)을 이용하여 radius를 0으로 초기화 시키는 것이다.<br>

또 다른 방법으로는 생성자 서두에 초기화를 진행하는 것이다. 이것이 개인적으로 문법이 헷갈린다.<br>
Circle:Circle() : Circle(0) {} 형태이다.<br>
Circle:Circle(int r) : radius(r) {}의 형태이다. <br>

물론, 멤버변수를 직접 초기에 클래스 선언부에서 초기화 해도 된다.<br>

내가 이 포스팅을 적은 이유는 바로 이 부분이다.<br>
Circle() 생성자를 이용하여 0으로 초기화 할때, 가장 주의해야 할점이다.<br>
메인함수에서 Circle c1()이라고 한다면 컴파일오류가 나기 때문이다. ()를 붙이면 컴파일러는 함수선언으로 취급하므로 ()는 떼도록 하자.<br>

또한, Circle:Circle(int r) : radius(r) {}의 형태를 왜 쓸까 궁금해서 생성형 AI의 답을 들어보았다.
![image](https://github.com/vivid-gamez/vivid-gamez.github.io/assets/103167519/890a15b1-35d0-44a6-abd7-7943036d0866)<br>
아직 내 수준에서는 효율성의 방면에서밖에 이해가 가질 않지만 도움이 되었다.<br>
메모리효율 관점에서 디폴트생성자를 이용한 생성 > 할당 순서로 이어지므로 비효율적이라는 이야기이다.

반대로 소멸자도 있으며, 소멸자는 기본생성자 형태의 이름 앞에 ~를 붙이면 된다.<br>
기본소멸자도 존재하므로, 필수적이진 않다. 그러나 여기서 알아야 할 점은 생성한 객체를 나중에 생성한 것이 먼저 소멸되는 형태라는 것이다.<br>
자료구조를 배우면 더욱 잘 알겠지만 생성자/소멸자의 실행순서는 스택 구조를 따른다는 이야기이다.<br>
LIFO구조(Last In First Out)를 이룬다는 이야기인데, 번역하면 후입선출 구조, 즉 나중에 생성한 것이 먼저 소멸되는 구조이다.<br>
이 개념은 책을 쌓는 것과 같다. 책을 쌓으면 맨 밑의 책을 꺼내기 위해서는 위의 책부터 하나씩 빼는 구조이다.

오늘은 여기까지로 마치도록 하겠다.

시험 공부 정리 겸 작성한 포스팅인데 자주 들러서 포스팅을 적지는 못할 것 같네요.
너무 오랜 기간 비워두지 않도록 신경 쓰도록 하겠습니다! **:)**





